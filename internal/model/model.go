package model

import (
   log "github.com/sirupsen/logrus"
   "strings"
)

// TODO models will always be NerdGraph entity type specific, this should proabaly be the core of a "framework" refactoring
// writeOnly model fields are dealt with here
type Model struct {
   Endpoint        *string           `json:",omitempty"`
   APIKey          *string           `json:",omitempty"`
   Guid            *string           `json:",omitempty"`
   EntityGuid      *string           `json:",omitempty"`
   ListQueryFilter *string           `json:",omitempty"`
   Variables       map[string]string `json:",omitempty"`
   Tags            []TagObject       `json:",omitempty"`
   Semantics       *string           `json:",omitempty"`
}

// TagObject is autogenerated from the json schema
type TagObject struct {
   Key    *string  `json:"Key,omitempty"`
   Values []string `json:"Values,omitempty"`
}

var usEndpoint = "https://api.newrelic.com/graphql"
var mapSemantics = "Map"

type Operation int

const (
   Create Operation = iota
   Read
   Update
   Delete
   List
)

// TODO will there be any NerdGraph model type specific defaults like the PK?
// TODO abstract out of framework

// These functions provide default values without modifying the model, keeps it simple

// AWS Semantics are pretty close to normal map semantics except Update requires the key to be present.
func (m *Model) IsAWSSemantics() bool {
   b := !m.IsNewRelicSemantics()
   log.Debugf("IsAWSSemantics: %t", b)
   return b
}

func (m *Model) IsNewRelicSemantics() (b bool) {
   b = false
   if m.Semantics != nil && strings.ToLower(*m.Semantics) == "newrelic" {
      b = true
   }
   log.Debugf("IsNewRelicSemantics: %t", b)
   return b
}

func (m *Model) GetEndpoint() string {
   if m.Endpoint == nil || *m.Endpoint == "" {
      return usEndpoint
   }
   return *m.Endpoint
}

func (m *Model) AllTagsPresent(tags map[string]string) (bool, string) {
   // Look for each tag key in the model in the response
   missingTags := ""
   for _, inTag := range m.Tags {
      if _, b := tags[*inTag.Key]; b {
         continue
      }
      missingTags = missingTags + " " + *inTag.Key
   }
   if missingTags == "" {
      return true, missingTags
   } else {
      return false, missingTags
   }
}
